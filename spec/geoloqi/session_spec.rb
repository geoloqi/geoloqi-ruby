require File.join File.dirname(__FILE__), '..', 'env.rb'

describe Geoloqi::Session do
  describe 'with nothing passed' do
    before do
      @session = Geoloqi::Session.new
    end

    it 'should have unique copy of config object' do
      @session.config.__id__.wont_equal Geoloqi.config.__id__
    end

    it 'should not find access token' do
      @session.access_token?.must_equal false
    end
  end

  describe 'with access token and throw exceptions not set' do
    it 'should throw api error exception' do
      stub_request(:get, api_url('badmethodcall')).
              with(:headers => auth_headers).
              to_return(:status => 404, :body => {:error => 'not_found'}.to_json)

      lambda {
        Geoloqi::Session.new(:access_token => 'access_token1234').get('badmethodcall')
      }.must_raise Geoloqi::ApiError
    end
  end

  describe 'custom exceptions scheme' do
    before do
      @session = Geoloqi::Session.new :access_token => 'access_token1234', :config => {:throw_exceptions => true,
                                                                                       :use_dynamic_exceptions => true}
    end

    it 'should throw api error exception with custom name' do
      stub_request(:get, api_url('specialerror')).
              with(:headers => auth_headers).
              to_return(:status => 404, :body => {:error => 'not_found'}.to_json)

      # Class is autogenerated, so pre-create it so we don't get a missing constant error.
      module Geoloqi
        class NotFoundError < ApiError; end
      end

      lambda {
        @session.get 'specialerror'
      }.must_raise Geoloqi::NotFoundError
    end
    
    it 'should throw api error exception without custom name if empty' do
      stub_request(:get, api_url('specialerror')).
              with(:headers => auth_headers).
              to_return(:status => 404, :body => {:error => ''}.to_json)

      lambda {
        @session.get 'specialerror'
      }.must_raise Geoloqi::ApiError
    end
  end

  describe 'with access token and throw exceptions false' do
    before do
      @session = Geoloqi::Session.new :access_token => 'access_token1234', :config => {:throw_exceptions => false}
    end

    it 'should not throw api error exception' do
      stub_request(:get, api_url('badmethodcall')).
              with(:headers => auth_headers).
              to_return(:status => 404, :body => {:error => 'not_found'}.to_json)

      response = @session.get 'badmethodcall'
      response[:error].must_equal 'not_found'
    end
  end

  describe 'with access token and hashie mash' do
    before do
      @session = Geoloqi::Session.new :access_token => 'access_token1234', :config => {:use_hashie_mash => true}
    end

    it 'should respond to method calls in addition to hash' do
      stub_request(:get, api_url('account/username')).
        with(:headers => {'Authorization'=>'OAuth access_token1234'}).
        to_return(:body => {:username => 'bulbasaurrulzok'}.to_json)

      response = @session.get 'account/username'

      response['username'].must_equal 'bulbasaurrulzok'
      response.username.must_equal    'bulbasaurrulzok'
      response[:username].must_equal  'bulbasaurrulzok'
    end
  end

  describe 'with access token and no config' do
    before do
      Geoloqi.config({})
      @session = Geoloqi::Session.new :access_token => ACCESS_TOKEN
    end
    
    it 'fails with establish without client_id and client_secret' do
      lambda { @session.establish }.must_raise Geoloqi::Error
    end

    it 'successfully makes a batch request' do
      stub_request(:post, api_url('batch/run')).
        with(:body => {
         :access_token => 'access_token1234',
         :batch => [
           {:relative_url => '/layer/create', :body => {:name => 'Test 1'}, :headers => {}},
           {:relative_url => '/layer/create', :body => {:name => 'Test 2'}, :headers => {}}
          ]
        }.to_json, 
        :headers => { 
          'Authorization' => 'OAuth access_token1234',
          'Content-Type'  => 'application/json'}).
        to_return(:status => 200, :body => {:result => [
          {:code => 201, 
           :headers => [{:name => "Date", :value => "Wed, 08 Feb 2012 02:16:11 GMT"}],
           :body => {:layer_id => "abc", :name => "Test 1"},
           :time_ms => 11.373
          },
          {:code => 201,
           :headers => [{:name => "Date", :value => "Wed, 08 Feb 2012 02:16:11 GMT"}],
           :body => { :layer_id => "def", :name => "Test 2" },
           :time_ms => 10.735
          }]}.to_json)

      response = @session.batch do
        post '/layer/create', :name => 'Test 1'
        post '/layer/create', :name => 'Test 2'
      end

      response.first[:code].must_equal 201
      response.first[:body][:layer_id].must_equal 'abc'
      response.last[:body][:layer_id].must_equal 'def'
    end

    it 'throws an exception on a hard request error' do
      stub_request(:get, api_url('crashing_method')).
        with(:headers => auth_headers).
        to_return(:status => 500, :body => 'Something broke hard!')

      lambda {
        Geoloqi::Session.new(:access_token => 'access_token1234').get('crashing_method')
      }.must_raise Geoloqi::Error
      
      begin
        Geoloqi::Session.new(:access_token => 'access_token1234').get('crashing_method')
      rescue => e
        e.message.must_equal "API returned invalid JSON. Status: 500 Body: Something broke hard!"
      end
    end

    it 'successfully makes call with array' do
      stub_request(:post, api_url('play_record_at_geoloqi_hq')).
        with(:headers => auth_headers, :body => [{:artist => 'Television'}].to_json).
        to_return(:body => {:result => 'ok'}.to_json)

      @session.post('play_record_at_geoloqi_hq', [{:artist => 'Television'}])[:result].must_equal 'ok'
    end

    it 'successfully makes call to api' do
      stub_request(:get, api_url('layer/info/Gx')).
        with(:headers => auth_headers).
        to_return(:status => 200, :body => {:layer_id => 'Gx'}.to_json)

      %w{/layer/info/Gx layer/info/Gx}.each do |path|
        @session.get(path)[:layer_id].must_equal 'Gx'
      end
    end

    describe 'location/history' do
      before do
        stub_request(:get, api_url('location/history?count=2')).
          with(:headers => auth_headers).
          to_return(:status => 200, :body => {:points => [1,2]}.to_json)
      end

      it 'makes a location/history call with get and hash params' do
        @session.get('location/history', :count => 2)[:points].count.must_equal 2
      end

      it 'makes a location/history call with get and query string directly in path' do
        @session.get('location/history?count=2')[:points].count.must_equal 2
      end

      it 'makes a location/history call with get and query string params' do
        @session.get('location/history', 'count=2')[:points].count.must_equal 2
      end
    end
  end

  describe 'with oauth id, secret, and access token via Geoloqi::Config' do
    it 'should load config' do
      @session = Geoloqi::Session.new :access_token => ACCESS_TOKEN,
                                      :config => Geoloqi::Config.new(:client_id => CLIENT_ID,
                                                                     :client_secret => CLIENT_SECRET)
      @session.config.client_id.must_equal     CLIENT_ID
      @session.config.client_secret.must_equal CLIENT_SECRET
    end
  end

  describe 'with- client id, client secret, and access token via direct hash' do
    before do
      @session = Geoloqi::Session.new :access_token => ACCESS_TOKEN,
                                      :config => {:client_id => CLIENT_ID,
                                                  :client_secret => CLIENT_SECRET}
    end

    it 'should return access token' do
      @session.access_token.must_equal ACCESS_TOKEN
    end

    it 'should recognize access token exists' do
      @session.access_token?.must_equal true
    end

    it 'gets authorize url' do
      authorize_url = @session.authorize_url 'http://blah.blah/test'
      authorize_url.must_equal "#{Geoloqi.oauth_url}?"+
                               "response_type=code&"+
                               "client_id=#{Rack::Utils.escape CLIENT_ID}&"+
                               "redirect_uri=#{Rack::Utils.escape 'http://blah.blah/test'}"
    end

    it 'gets authorize url with scope' do
      authorize_url = @session.authorize_url 'http://blah.blah/test', :scope => 'party_hard'
      authorize_url.must_equal "#{Geoloqi.oauth_url}?"+
                               "response_type=code&"+
                               "client_id=#{Rack::Utils.escape CLIENT_ID}&"+
                               "redirect_uri=#{Rack::Utils.escape 'http://blah.blah/test'}&"+
                               "scope=party_hard"
    end
  end

  describe 'with bunk access token' do
    before do
      @session = Geoloqi::Session.new :access_token => 'hey brah whats up let me in its cool 8)'
    end

    it 'fails with an exception' do
      stub_request(:post, api_url('message/send')).
              with(:headers => auth_headers('hey brah whats up let me in its cool 8)')).
              to_return(:status => 401, :body => {:error => 'invalid_token'}.to_json)

      begin
        @session.post 'message/send'
      rescue Exception => e
        e.class.must_equal Geoloqi::ApiError
        e.status.must_equal 401
        e.type.must_equal 'invalid_token'
        e.message.must_equal 'invalid_token (401)'
      end
    end
  end

  # PUT GENERAL TESTS IN HERE

  describe 'with config' do
    before do
      @session = Geoloqi::Session.new :config => {:client_id => CLIENT_ID, :client_secret => CLIENT_SECRET}
    end

    it 'should automatically provide client_id and client_secret for app resource calls' do
      stub_request(:get, api_url_with_auth('user/list/notme')).
        to_return(:status => 200,
                  :body => {:username => 'captainpicard'}.to_json)

      resp = @session.app_get 'user/list/notme'
      resp[:username].must_equal 'captainpicard'      
      
      stub_request(:post, api_url_with_auth('user/create_anon')).
        with(:body => {:device_id => 'abcd'}.to_json).
        to_return(:status => 200,
                  :body => {:username => 'captainpicard'}.to_json)

      resp = @session.app_post 'user/create_anon', {:device_id => 'abcd'}
      resp[:username].must_equal 'captainpicard'
    end

    it 'retreives application access token data' do
      stub_request(:post, api_url('oauth/token')).
        with(:body => {:client_id => CLIENT_ID,
                       :client_secret => CLIENT_SECRET,
                       :grant_type => 'client_credentials'}.to_json).
        to_return(:status => 200,
                  :body => {:display_name => 'My App',
                            :username => 'madeuphashdontuseforanything',
                            :user_id => 'userid',
                            :is_anonymous => 0,
                            :access_token => 'app_access_token',
                            :scope => nil,
                            :expires_at => nil}.to_json)

      resp = @session.establish :grant_type => 'client_credentials'

      resp[:display_name].must_equal 'My App'
      resp[:access_token].must_equal 'app_access_token'

      @session.application_access_token.must_equal 'app_access_token'

      # Test the cache.
      @session.send(:instance_variable_set, :'@application_access_token', 'works')
      @session.application_access_token.must_equal 'works'
    end

    it 'retrieves auth with mock' do
      stub_request(:post, api_url('oauth/token')).
        with(:body => {:client_id => CLIENT_ID,
                       :client_secret => CLIENT_SECRET,
                       :grant_type => "authorization_code",
                       :code => "1234",
                       :redirect_uri => "http://example.com"}.to_json).
        to_return(:body => {:access_token => 'access_token1234',
                            :scope => nil,
                            :expires_in => '86400',
                            :refresh_token => 'refresh_token1234'}.to_json)

      response = @session.get_auth '1234', 'http://example.com'

      {:access_token => 'access_token1234',
       :scope => nil,
       :expires_in => '86400',
       :refresh_token => 'refresh_token1234'}.each do |k,v|
        response[k].must_equal v
      end
    end

    it 'does not refresh when never expires' do
      stub_request(:post, api_url('oauth/token')).
        with(:body => {:client_id => CLIENT_ID,
                       :client_secret => CLIENT_SECRET,
                       :grant_type => "authorization_code",
                       :code => "1234",
                       :redirect_uri => "http://neverexpires.example.com/"}.to_json).
        to_return(:body => {:access_token => 'access_token1234',
                            :scope => nil,
                            :expires_in => '0',
                            :refresh_token => 'never_expires'}.to_json)
                            
      stub_request(:get, api_url('account/username')).
        with(:headers => {'Authorization'=>'OAuth access_token1234'}).
        to_return(:body => {:username => 'bulbasaurrulzok'}.to_json)

      response = @session.get_auth '1234', 'http://neverexpires.example.com/'

      @session.auth[:expires_in].must_equal '0'
      @session.auth[:expires_at].nil?.must_equal true

      response = @session.get 'account/username'

      @session.auth[:access_token].must_equal 'access_token1234'
      response[:username].must_equal 'bulbasaurrulzok'
    end
    
    it 'does not attempt to refresh for auth code expire' do
      stub_request(:post, api_url('oauth/token')).
        with(:body => {:client_id => CLIENT_ID,
                       :client_secret => CLIENT_SECRET,
                       :grant_type => "authorization_code",
                       :code => "1234",
                       :redirect_uri => "http://expired_code.example.com/"}.to_json).
        to_return(:body => {:access_token => 'access_token1234',
                            :scope => nil,
                            :expires_in => '0',
                            :refresh_token => 'never_expires'}.to_json)
      
      stub_request(:get, api_url('account/username?code=1234')).
        with(:headers => auth_headers).
        to_return(:status => 200, :body => {:points => [1,2]}.to_json)
      
      ###################################################################### FINISH IMPLEMENTING
    end
  end

  describe 'with config and expired auth' do
    before do
      @session = Geoloqi::Session.new :config => {:client_id => CLIENT_ID, :client_secret => CLIENT_SECRET},
                                      :auth => { :access_token => 'access_token1234',
                                                 :scope => nil,
                                                 :expires_in => '86400',
                                                 :expires_at => Time.at(0).rfc2822,
                                                 :refresh_token => 'refresh_token1234' }
    end

    it 'retrieves new access token and retries query if expired' do
      stub_request(:post, api_url('oauth/token')).
        with(:body => {:client_id => CLIENT_ID,
                       :client_secret => CLIENT_SECRET,
                       :grant_type => "refresh_token",
                       :refresh_token => "refresh_token1234"}.to_json).
        to_return(:body => {:access_token => 'access_token4567',
                            :scope => nil,
                            :expires_in => '5000',
                            :refresh_token => 'refresh_token4567'}.to_json)

      stub_request(:get, api_url('account/username')).
        with(:headers => {'Authorization'=>'OAuth access_token4567'}).
        to_return(:body => {:username => 'pikachu4lyfe'}.to_json)

      @session.get 'account/username'
      @session.auth[:access_token].must_equal 'access_token4567'
    end
  end
end
